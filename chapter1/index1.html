<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>const</title>
    <script type="text/javascript">
        //Example1:(const声明一个只读的常量。一旦声明，常量的值就不能改变)
//        const PI = 3.1415;
//        PI = 3;

        //Example2:(const一旦声明变量，就必须立即初始化，不能留到以后赋值)
//        const tmp;

        //Example3:(const的作用域与let命令相同 只在声明所在的块级作用域内有效)
//        if (true) {
//            const MAX = 5;
//        }
//        console.log(MAX);

        //Example4:(const同样存在暂时性死区 只能在声明的位置后面使用 主要和var对比)
//        if (true) {
//            console.log(tmp); // ReferenceError
//            const tmp = 5;
//        }

        //Example5:(const声明的常量，也与let一样不可重复声明)
//        var message = "Hello!";
//        let age = 25;
//
//        // 以下两行都会报错
//        const message = "Goodbye!";
//        const age = 30;

        //Example6:(const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。
        // 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。
        // 但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，
        // const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制)
//        const foo = {};

        // 为 foo 添加一个属性，可以成功
//        foo.prop = 123;
//        foo.prop // 123

        // 将 foo 指向另一个对象，就会报错
//        foo = {};

        //Example7:(如果想让一个const常量，本身值也不能改变，使用Object.freeze())
        const foo = Object.freeze({});
        // 常规模式时，下面一行不起作用；
        // 严格模式时，该行会报错
//        foo.prop = 123;
//        console.log(foo);

    </script>
</head>
<body>
    <h1>const关键字</h1>
</body>
</html>